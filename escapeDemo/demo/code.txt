class Class1 {
    Class4 field1;
    
    
    Class1() {}

    void method1() {
        try {
            method2(new Class1());
        } catch(Class2 exception) {
            Class4 local = exception.method1();
            if(local != null) {
                local.method1();
            }
            method7(exception);
            field1 = new Class4();
            if(exception instanceof Class3) {
                ((Class3) exception).method3(field1);
                
            }
            throw exception;
        }
    }
    
    static void method2(Class1 arg) {
        arg.method3();
    }

    void method3()  {
        method4(null);
    }

    void method4(Class3 arg) {
        method5(arg);
    }

    void method5(Class3 arg) {
        Class3 local = method6();
        Class3.method2(this);
        throw local;
    }

    Class3 method6() {
        Class3 local = new Class3();
        local.field4.method1();
        return local;

    }

    Class4 method7(Class2 arg) {
        return null;
    }
}


class Class2 extends java.lang.RuntimeException {
    boolean field2;
    Class2 field3;

    Class2() {}

    Class4 method1() {
        field2 = true;
        return null;
    }
  
}

class Class3 extends Class2 {
    Class4 field4;
    static Class4 field5;
    
    Class3() {
        field4 = new Class4();
    }

    /**
     * overrides method7 in parent class
     */
    Class4 method1() {
        return null;
    }

    static void method2(Class1 arg) {
        field5 = null;
    }

    final void method3(Class4 arg) {
        field5 = arg;
    }
}


class Class4 {
    char[] field5;

    Class4() {}

    void method1() {}
}



WRONG   
Object 1 is the generic object created for the parameter to the initial method method1
Object 2 is the instance of Class1 created in method1
Object 3 is the generic object created due to the virtual method invocation of Class2.method1
Object 4 is the instance of Class4 created in method1
Object 5 is the instance of Class3 created in method6
Object 6 is the instance of Class4 created in the constructor of Class3



Missing: 
-generic object splitting
-unknown method definitions (methods not loaded)


The analysis is applied to method1 in Class1.  Because this method is not static, there is a generic instance of Class1 that is instantiated to be passed to the method.  From that point onwards, ITA analysis determines the flow of objects.  For purposes of escape analysis, the fields with primitive (non-object) types can be ignored, since they have no effect upon the flow of objects.  

Shown in this example is ITA exception handling, as the instance of Class3 is thrown from method5.  In method4, the object is not caught, and therefore the object is propagated but the object is not available to method5 in other ways.  The analysis must also account for unchecked exceptions and exceptions generated by the virtual machine.  In general, for any unchecked exceptions that may be caught, the analysis must generate these exceptions whereever they may be generated.

Also shown is a virtual method resolution, in which an instruction's invocation of Class2.method1 is actually resolved to Class3.method1, the overriding method, when the invocation is applied to object 5.

The example includes a generic object that is an argument to the initial method.  A method is invoked on this object, which therefore requires a generic method invocation, which causes the creation of another generic object, as the returned object from the generic method invocation.

Intraprocedural analysis is included in this example.  For instance, the two separate instances of Class1 in method1 are not passed to the same locations as determined by the intraprocedural analysis.

Not included in this example are the actions of generic object splitting, and the handling of unknown method definitions (due to native methods or methods, methods not loaded, or methods whose definition is unknown for other reasons).  There is not an example of a thread object root, or a returned object root.

When the analysis completes, the roots of the search for escaping objects are:
-Object 1, the generic object argument to the initial method, method1
-the accessed static field, field5
-Object 5, which was thrown from method1 and thus escaped directly
-the generic method invocation method7

In the example, only one object escapes, Object 6.  This object is never present in the initial method.  Therefore, in the event that the initial method leads to an invocation of the constructor of Class 6, under this scenario we know the object created in that constructor cannot escape.  Note that this does not necessarily mean that object will never escape (although in this case the object cannot escape regardless of the calling context).  To determine if an object created in a particular method will never escape, the algorithm must be applied with that particular method as the initial method.

Knowing that Object 6 cannot escape with this calling context, it is possible to apply optimizations to the object created there in this context, eliminating locks on the object, or allocating the object on the stack.
